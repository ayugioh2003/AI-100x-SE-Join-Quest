class i{row;col;constructor(e,t){this.row=e,this.col=t}equals(e){return this.row===e.row&&this.col===e.col}toString(){return`(${this.row}, ${this.col})`}}var o=(w=>(w.RED="RED",w.BLACK="BLACK",w))(o||{}),h=(w=>(w.GENERAL="GENERAL",w.GUARD="GUARD",w.ROOK="ROOK",w.HORSE="HORSE",w.CANNON="CANNON",w.ELEPHANT="ELEPHANT",w.SOLDIER="SOLDIER",w))(h||{}),A=(w=>(w.IN_PROGRESS="IN_PROGRESS",w.CHECKMATE="CHECKMATE",w.STALEMATE="STALEMATE",w.DRAW="DRAW",w))(A||{});class P{constructor(e,t,s){this.color=e,this.type=t,this.position=s}getPossibleMoves(e){const t=[];for(let s=1;s<=10;s++)for(let c=1;c<=9;c++){const n=new i(s,c);this.isValidMove(e,this.position,n)&&t.push(n)}return t}}class M extends P{constructor(e,t){super(e,h.GENERAL,t)}isValidMove(e,t,s){if(!e.isPositionValid(s))return!1;const c=e.getPieceAt(s);if(c&&c.color===this.color||!this.isWithinPalace(s))return!1;const n=Math.abs(s.row-t.row),r=Math.abs(s.col-t.col);return!(!(n===1&&r===0||n===0&&r===1)||this.wouldFaceOpponentGeneral(e,t,s))}isWithinPalace(e){return this.color===o.RED?e.row>=1&&e.row<=3&&e.col>=4&&e.col<=6:e.row>=8&&e.row<=10&&e.col>=4&&e.col<=6}wouldFaceOpponentGeneral(e,t,s){const c=this.color===o.RED?o.BLACK:o.RED;let n=null;for(let r=1;r<=10;r++){for(let l=1;l<=9;l++){const a=new i(r,l),f=e.getPieceAt(a);if(f&&f.type===h.GENERAL&&f.color===c){n=a;break}}if(n)break}if(n&&s.col===n.col){const r=Math.min(s.row,n.row)+1,l=Math.max(s.row,n.row)-1;let a=!1;for(let f=r;f<=l;f++){const C=new i(f,s.col);if(e.getPieceAt(C)&&!C.equals(t)){a=!0;break}}return!a}return!1}}class E extends P{constructor(e,t){super(e,h.GUARD,t)}isValidMove(e,t,s){if(!e.isPositionValid(s))return!1;const c=e.getPieceAt(s);if(c&&c.color===this.color||!this.isWithinPalace(s))return!1;const n=Math.abs(s.row-t.row),r=Math.abs(s.col-t.col);return n===1&&r===1}isWithinPalace(e){return this.color===o.RED?[{row:1,col:4},{row:1,col:6},{row:2,col:5},{row:3,col:4},{row:3,col:6}].some(s=>s.row===e.row&&s.col===e.col):[{row:8,col:4},{row:8,col:6},{row:9,col:5},{row:10,col:4},{row:10,col:6}].some(s=>s.row===e.row&&s.col===e.col)}}class R extends P{constructor(e,t){super(e,h.ROOK,t)}isValidMove(e,t,s){if(!e.isPositionValid(s))return!1;const c=e.getPieceAt(s);if(c&&c.color===this.color)return!1;const n=Math.abs(s.row-t.row),r=Math.abs(s.col-t.col);return!(!(n===0||r===0)||this.hasObstaclesBetween(e,t,s))}hasObstaclesBetween(e,t,s){const c=t.row===s.row?0:s.row>t.row?1:-1,n=t.col===s.col?0:s.col>t.col?1:-1;let r=t.row+c,l=t.col+n;for(;r!==s.row||l!==s.col;){if(e.getPieceAt(new i(r,l)))return!0;r+=c,l+=n}return!1}}class d extends P{constructor(e,t){super(e,h.HORSE,t)}isValidMove(e,t,s){if(!e.isPositionValid(s))return!1;const c=e.getPieceAt(s);if(c&&c.color===this.color)return!1;const n=Math.abs(s.row-t.row),r=Math.abs(s.col-t.col);return!(!(n===2&&r===1||n===1&&r===2)||this.isBlocked(e,t,s))}isBlocked(e,t,s){const c=s.row-t.row,n=s.col-t.col;let r;return Math.abs(c)===2?r=new i(t.row+(c>0?1:-1),t.col):r=new i(t.row,t.col+(n>0?1:-1)),e.getPieceAt(r)!==null}}class D extends P{constructor(e,t){super(e,h.CANNON,t)}isValidMove(e,t,s){if(!e.isPositionValid(s))return!1;const c=e.getPieceAt(s);if(c&&c.color===this.color)return!1;const n=Math.abs(s.row-t.row),r=Math.abs(s.col-t.col);if(!(n===0||r===0))return!1;const l=this.countPiecesBetween(e,t,s);return c?l===1:l===0}countPiecesBetween(e,t,s){const c=t.row===s.row?0:s.row>t.row?1:-1,n=t.col===s.col?0:s.col>t.col?1:-1;let r=t.row+c,l=t.col+n,a=0;for(;r!==s.row||l!==s.col;)e.getPieceAt(new i(r,l))&&a++,r+=c,l+=n;return a}}class g extends P{constructor(e,t){super(e,h.ELEPHANT,t)}isValidMove(e,t,s){if(!e.isPositionValid(s))return!1;const c=e.getPieceAt(s);if(c&&c.color===this.color||!this.isWithinOwnSide(s))return!1;const n=Math.abs(s.row-t.row),r=Math.abs(s.col-t.col);return!(!(n===2&&r===2)||this.isEyeBlocked(e,t,s))}isWithinOwnSide(e){return this.color===o.RED?e.row<=5:e.row>=6}isEyeBlocked(e,t,s){const c=t.row+(s.row-t.row)/2,n=t.col+(s.col-t.col)/2,r=new i(c,n);return e.getPieceAt(r)!==null}}class u extends P{constructor(e,t){super(e,h.SOLDIER,t)}isValidMove(e,t,s){if(!e.isPositionValid(s))return!1;const c=e.getPieceAt(s);if(c&&c.color===this.color)return!1;const n=s.row-t.row,r=s.col-t.col;return Math.abs(n)+Math.abs(r)!==1?!1:this.hasCrossedRiver(t)?this.color===o.RED?n>=0:n<=0:this.color===o.RED?n===1&&r===0:n===-1&&r===0}hasCrossedRiver(e){return this.color===o.RED?e.row>5:e.row<6}}class v{board;constructor(){this.board=Array(10).fill(null).map(()=>Array(9).fill(null)),this.initializeBoard()}initializeBoard(){this.setPieceAt(new i(1,1),new R(o.RED,new i(1,1))),this.setPieceAt(new i(1,2),new d(o.RED,new i(1,2))),this.setPieceAt(new i(1,3),new g(o.RED,new i(1,3))),this.setPieceAt(new i(1,4),new E(o.RED,new i(1,4))),this.setPieceAt(new i(1,5),new M(o.RED,new i(1,5))),this.setPieceAt(new i(1,6),new E(o.RED,new i(1,6))),this.setPieceAt(new i(1,7),new g(o.RED,new i(1,7))),this.setPieceAt(new i(1,8),new d(o.RED,new i(1,8))),this.setPieceAt(new i(1,9),new R(o.RED,new i(1,9))),this.setPieceAt(new i(3,2),new D(o.RED,new i(3,2))),this.setPieceAt(new i(3,8),new D(o.RED,new i(3,8))),this.setPieceAt(new i(4,1),new u(o.RED,new i(4,1))),this.setPieceAt(new i(4,3),new u(o.RED,new i(4,3))),this.setPieceAt(new i(4,5),new u(o.RED,new i(4,5))),this.setPieceAt(new i(4,7),new u(o.RED,new i(4,7))),this.setPieceAt(new i(4,9),new u(o.RED,new i(4,9))),this.setPieceAt(new i(7,1),new u(o.BLACK,new i(7,1))),this.setPieceAt(new i(7,3),new u(o.BLACK,new i(7,3))),this.setPieceAt(new i(7,5),new u(o.BLACK,new i(7,5))),this.setPieceAt(new i(7,7),new u(o.BLACK,new i(7,7))),this.setPieceAt(new i(7,9),new u(o.BLACK,new i(7,9))),this.setPieceAt(new i(8,2),new D(o.BLACK,new i(8,2))),this.setPieceAt(new i(8,8),new D(o.BLACK,new i(8,8))),this.setPieceAt(new i(10,1),new R(o.BLACK,new i(10,1))),this.setPieceAt(new i(10,2),new d(o.BLACK,new i(10,2))),this.setPieceAt(new i(10,3),new g(o.BLACK,new i(10,3))),this.setPieceAt(new i(10,4),new E(o.BLACK,new i(10,4))),this.setPieceAt(new i(10,5),new M(o.BLACK,new i(10,5))),this.setPieceAt(new i(10,6),new E(o.BLACK,new i(10,6))),this.setPieceAt(new i(10,7),new g(o.BLACK,new i(10,7))),this.setPieceAt(new i(10,8),new d(o.BLACK,new i(10,8))),this.setPieceAt(new i(10,9),new R(o.BLACK,new i(10,9)))}getPieceAt(e){return this.isPositionValid(e)?this.board[e.row-1][e.col-1]:null}setPieceAt(e,t){this.isPositionValid(e)&&(this.board[e.row-1][e.col-1]=t)}movePiece(e,t){const s=this.getPieceAt(e);s&&(this.setPieceAt(e,null),this.setPieceAt(t,s))}isPositionValid(e){return e.row>=1&&e.row<=10&&e.col>=1&&e.col<=9}isPathClear(e,t){const s=t.row-e.row,c=t.col-e.col;if(Math.abs(s)===Math.abs(c)){const n=s>0?1:-1,r=c>0?1:-1;for(let l=1;l<Math.abs(s);l++){const a=new i(e.row+l*n,e.col+l*r);if(this.getPieceAt(a))return!1}}else if(s===0){const n=c>0?1:-1;for(let r=e.col+n;r!==t.col;r+=n){const l=new i(e.row,r);if(this.getPieceAt(l))return!1}}else if(c===0){const n=s>0?1:-1;for(let r=e.row+n;r!==t.row;r+=n){const l=new i(r,e.col);if(this.getPieceAt(l))return!1}}return!0}countPiecesBetween(e,t){const s=t.row-e.row,c=t.col-e.col;let n=0;if(s===0){const r=c>0?1:-1;for(let l=e.col+r;l!==t.col;l+=r){const a=new i(e.row,l);this.getPieceAt(a)&&n++}}else if(c===0){const r=s>0?1:-1;for(let l=e.row+r;l!==t.row;l+=r){const a=new i(l,e.col);this.getPieceAt(a)&&n++}}return n}}class B{board;currentPlayer=o.RED;gameState=A.IN_PROGRESS;winner=void 0;moveHistory=[];constructor(){this.board=new v}makeMove(e,t){const s=this.board.getPieceAt(e);if(!s)return{isLegal:!1,success:!1,gameOver:!1,reason:"No piece at source position",captured:!1};if(s.color!==this.currentPlayer)return{isLegal:!1,success:!1,gameOver:!1,reason:"Not your piece",captured:!1};if(!s.isValidMove(this.board,e,t))return{isLegal:!1,success:!1,gameOver:!1,reason:"Invalid move",captured:!1};const n=this.board.getPieceAt(t);this.board.movePiece(e,t),s.position=t;let r=!1,l;return n&&n.type===h.GENERAL?(r=!0,l=this.currentPlayer,this.winner=this.currentPlayer,this.gameState=A.CHECKMATE):this.switchPlayer(),{isLegal:!0,success:!0,gameOver:r,winner:l,reason:void 0,captured:n!==null}}getBoard(){return this.board}getCurrentPlayer(){return this.currentPlayer}isGameOver(){return this.gameState===A.CHECKMATE||this.gameState===A.STALEMATE||this.gameState===A.DRAW}getWinner(){return this.winner}switchPlayer(){this.currentPlayer=this.currentPlayer===o.RED?o.BLACK:o.RED}}export{B as C,i as P,o as a};
